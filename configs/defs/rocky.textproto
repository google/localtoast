benchmark_configs: {
  id: "var-noexec"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure noexec option set on /var partition"
    description: "The noexec mount option specifies that the filesystem cannot contain executable binaries."
    rationale:
      "Since the /var filesystem is only intended for variable files such as logs, set this option to "
      "ensure that users cannot run executable binaries from /var."
    remediation:
      "Edit the /etc/fstab file and add noexec to the fourth field (mounting options) for the /var "
      "partition.\n"
      "Example:\n"
      "\n```\n"
      "<device> /var <fstype> defaults, rw,nosuid, nodev, noexec, relatime 0 0\n"
      "```\n\n"
      "Run the following command to remount /var with the configured options:\n"
      "\n```\n"
      "mount -o remount /var\n"
      "```\n\n"
      "References:\n"
      "1. See the fstab(5) manual page for more information."
    cis_benchmark: {
      profile_level: 1
      severity: LOW
    }
    scan_instructions:
      "scan_type_specific:{instance_scanning:{"
      "check_alternatives:{"
      "  file_checks:{"
      "    files_to_check:{single_file:{path:\"/proc/self/mountinfo\"}}"
      "    content_entry:{"
      "      match_type: ALL_MATCH_ANY_ORDER"
      "      match_criteria: {"
      "        filter_regex: \".* /var .* - .*\""
      "        expected_regex: \".* /var .*noexec.* - .*\""
      "      }"
      "    }"
      "  }"
      "}"
      "check_alternatives:{"
      "  file_checks:{"
      "    files_to_check:{single_file:{path:\"/proc/self/mountinfo\"}}"
      "    content_entry:{"
      "      match_type: NONE_MATCH"
      "      match_criteria: {"
      "        filter_regex: \".* /var .* - .*\""
      "        expected_regex: \".* /var .* - .*\""
      "      }"
      "    }"
      "  }"
      "}}}"
  }
}
benchmark_configs: {
  id: "home-usrquota"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure usrquota option set on /home partition"
    description: "The usrquota mount optionallows for the filesystem to have disk quotas configured."
    rationale:
      "To ensure the availability of disk space on /home, it is important to limit the impact a single "
      "user or group can cause for other users (or the wider system) by accidentally filling up the "
      "partition. Quotas can also be applied to inodes for filesystems where inode exhaustion is a "
      "concern."
    remediation:
      "Edit the /etc/fstab file and add usrquota to the fourth field (mounting options) for the "
      "/home partition. "
      "Example:\n"
      "\n```\n"
      "<device> /home <fstype> defaults, rw, usrquota, grpquota, nodev, relatime\n"
      "```\n\n"
      "Run the following command to remount /home with the configured options:\n"
      "\n```\n"
      "# mount -o remount /home\n"
      "```\n\n"
      "Create the quota database. This example will ignore any existing quotafiles.\n"
      "\n```\n"
      "quotacheck -cugv /home \n"
      "quotacheck: Your kernel probably supports journaled quota but you are not \n"
      "using it. Consider switching to journaled quota to avoid running quotacheck \n"
      "after an unclean shutdown. \n"
      "quotacheck: Scanning /dev/sdb [/home] done \n"
      "quotacheck: Cannot stat old user quota file /home/aquota.user: No such file \n"
      "or directory. Usage will not be subtracted. \n"
      "quotacheck: Cannot stat old group quota file /home/aquota.group: No such file \n"
      "or directory. Usage will not be subtracted. \n"
      "quotacheck: Cannot stat old user quota file /home/aquota.user: No such file \n"
      "or directory. Usage will not be subtracted. \n"
      "quotacheck: Cannot stat old group quota file /home/aquota.group: No such file \n"
      "or directory. Usage will not be subtracted. \n"
      "quotacheck: Checked 8 directories and 0 files \n"
      "quotacheck: Old file not found. \n"
      "quotacheck: Old file not found. \n"
      "```\n\n"
      "Restore SELinux context on the quota database files. Order of operations is importantas "
      "quotaon will set the immutable attribute on the files and thus restorecon will fail. "
      "\n```\n"
      "restorecon /home/aquota.user\n"
      "```\n\n"
      "Enable quotas on the partition:\n"
      "\n```\n"
      "quotaon -vug /home\n"
      "/dev/sdb [/home]: group quotas turned on\n"
      "/dev/sdb [/home]: user quotas turned on\n"
      "```\n\n"
      "References:\n"
      "1. See the fstab(5) and edquota(8) manual pages for more information."
    cis_benchmark: {
      profile_level: 1
      severity: LOW
    }
    scan_instructions:
      "scan_type_specific:{instance_scanning:{"
      "check_alternatives:{"
      "  file_checks:{"
      "    files_to_check:{single_file:{path:\"/proc/self/mountinfo\"}}"
      "    content_entry:{"
      "      match_type: ALL_MATCH_ANY_ORDER"
      "      match_criteria: {"
      "          filter_regex: \".* /home .*\""
      "          expected_regex: \".* /home .*usrquota.*\""
      "      }"
      "    }"
      "  }"
      "}"
      "check_alternatives:{"
      "  file_checks:{"
      "    files_to_check:{single_file:{path:\"/proc/self/mountinfo\"}}"
      "    content_entry:{"
      "      match_type: NONE_MATCH"
      "      match_criteria: {"
      "          filter_regex: \".* /home .* - .*\""
      "          expected_regex: \".* /home .* - .*\""
      "      }"
      "    }"
      "  }"
      "}}}"
  }
}
benchmark_configs: {
  id: "home-grpquota"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure grpquota option set on /home partition"
    description: "The grpquota mount option allows for the filesystem to have disk quotas configured."
    rationale:
      "To ensure the availability of disk space on /home, it is important to limit the impact a single "
      "user or group can cause for other users (or the wider system) by accidentally filling up the "
      "partition. Quotas can also be applied to inodes for filesystems where inode exhaustion is a "
      "concern."
    remediation:
      "Edit the /etc/fstab file and add grpquota to the fourth field (mounting options) for the "
      "/home partition. "
      "Example:\n"
      "\n```\n"
      "<device> /home <fstype> defaults, rw, usrquota, grpquota, nodev, relatime\n"
      "```\n\n"
      "Run the following command to remount /home with the configured options:\n"
      "\n```\n"
      "mount -o remount /home\n"
      "```\n\n"
      "Create the quota database. This example will ignore any existing quotafiles.\n"
      "\n```\n"
      "quotacheck -cugv /home\n"
      "quotacheck: Your kernel probably supports journaled quota but you are not\n"
      "using it. Consider switching to journaled quota to avoid running quotacheck\n"
      "after an unclean shutdown.\n"
      "quotacheck: Scanning /dev/sdb [/home] done\n"
      "quotacheck: Cannot stat old user quota file /home/aquota.user: No such file\n"
      "or directory. Usage will not be subtracted.\n"
      "quotacheck: Cannot stat old group quota file /home/aquota.group: No such file\n"
      "or directory. Usage will not be subtracted.\n"
      "quotacheck: Cannot stat old user quota file /home/aquota.user: No such file\n"
      "or directory. Usage will not be subtracted.\n"
      "quotacheck: Cannot stat old group quota file /home/aquota.group: No such file\n"
      "or directory. Usage will not be subtracted.\n"
      "quotacheck: Checked 8 directories and 0 files\n"
      "quotacheck: Old file not found.\n"
      "quotacheck: Old file not found.\n"
      "```\n\n"
      "Restore SELinux context on the quota database files. Order of operations is importantas "
      "quotaon will set the immutable attribute on the files and thus restorecon will fail.\n"
      "\n```\n"
      "restorecon /home/aquota.group\n"
      "```\n\n"
      "Enable quotas on the partition:\n"
      "\n```\n"
      "quotaon -vug /home\n"
      "/dev/sdb [/home]: group quotas turned on\n"
      "/dev/sdb [/home]: user quotas turned on\n"
      "```\n\n"
      "References:\n"
      "1. See the fstab(5) and edquota(8) manual pages for more information."
    cis_benchmark: {
      profile_level: 1
      severity: LOW
    }
    scan_instructions:
      "scan_type_specific:{instance_scanning:{"
      "check_alternatives:{"
      "  file_checks:{"
      "    files_to_check:{single_file:{path:\"/proc/self/mountinfo\"}}"
      "    content_entry:{"
      "      match_type: ALL_MATCH_ANY_ORDER"
      "      match_criteria: {"
      "          filter_regex: \".* /home .*\""
      "          expected_regex: \".* /home .*grpgquota.*\""
      "      }"
      "    }"
      "  }"
      "}"
      "check_alternatives:{"
      "  file_checks:{"
      "    files_to_check:{single_file:{path:\"/proc/self/mountinfo\"}}"
      "    content_entry:{"
      "      match_type: NONE_MATCH"
      "      match_criteria: {"
      "          filter_regex: \".* /home .* - .*\""
      "          expected_regex: \".* /home .* - .*\""
      "      }"
      "    }"
      "  }"
      "}}}"
  }
}
benchmark_configs: {
  id: "boot-rescue-mode-password"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure authentication is required when booting into rescue mode"
    description:
      "Rescue mode (former single user mode) is used for recovery when the system detects an "
      "issue during boot or by manual selection from the bootloader."
    rationale:
      "Requiring authentication in rescue mode (former single user mode) prevents an "
      "unauthorized user from rebooting the system into rescue mode to gainroot privileges "
      "without credentials."
    remediation:
      "The systemd drop-in files mustbe created if it is necessary to change the default settings:\n"
      "Create the file /etc/systemd/system/rescue.service.d/00-require-auth.conf which "
      "contains only the configuration to be overridden:\n"
      "\n```\n"
      "[Service]\n"
      "ExecStart=-/usr/lib/systemd/systemd-sulogin-shell rescue\n"
      "```\n\n"
    cis_benchmark: {
      profile_level: 1
      severity: LOW
    }
    scan_instructions:
      "generic:{"
      " check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{single_file:{path:\"/usr/lib/systemd/system/rescue.service\"}}"
      "      files_to_check:{files_in_dir:{dir_path:\"/etc/systemd/system/rescue.service.d\",recursive:true}}"
      "      content_entry:{"
      "        match_type: ALL_MATCH_ANY_ORDER"
      "        match_criteria: {"
      "          filter_regex: \".*/systemd-sulogin-shell.*\""
      "          expected_regex: \"ExecStart=-/usr/lib/systemd/systemd-sulogin-shell rescue\""
      "        }"
      "      }"
      "    }"
      " }"
      "}"
  }
}
benchmark_configs: {
  id: "systemwide-crypto-policy-not-legacy"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure system-wide crypto policy is not legacy"
    description:
      "The system-wide crypto-policies followed by the crypto core components allow "
      "consistently deprecating and disabling algorithms system-wide.\n"
      "The individual policy levels (DEFAULT, LEGACY, FUTURE, and FIPS) are included in the "
      "crypto-policies(7) package."
    rationale:
      "If the Legacy system-wide crypto policy is selected, itincludes support for TLS 1.0, TLS 1.1, "
      "and SSH2 protocols or later. The algorithms DSA, 3DES, and RC4 are allowed, while RSA "
      "and Diffie-Hellman parameters are accepted if larger than 1023-bits.\n"
      "These legacy protocols and algorithms can make the system vulnerable to attacks, "
      "including those listed in RFC 7457\n"
      "Impact:\n"
      "Environments that require compatibility with older insecure protocols may require the use "
      "of the less secure LEGACY policy level."
    remediation:
      "Run the following command to change the system-wide crypto policy\n"
      "\n```\n"
      "update-crypto-policies --set <CRYPTO POLICY>\n"
      "```\n\n"
      "Example:\n"
      "\n```\n"
      "update-crypto-policies --set DEFAULT\n"
      "```\n\n"
      "Run the following to make the updated system-wide crypto policy active\n"
      "\n```\n"
      "update-crypto-policies\n"
      "```\n\n"
      "References:\n"
      "1. CRYPTO-POLICIES(7)\n"
      "2. https://access.redhat.com/articles/3642912#what-polices-are-provided-1"
    cis_benchmark: {
      profile_level: 1
      severity: LOW
    }
    scan_instructions:
      "generic:{"
      "  check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{single_file:{path:\"/etc/crypto-policies/config\"}}"
      "      content_entry:{"
      "        match_type: NONE_MATCH"
      "        match_criteria: {"
      "          filter_regex: \"\\\\s*LEGACY\\\\s*(\\\\s+#.*)?\""
      "          expected_regex: \"\\\\s*LEGACY\\\\s*(\\\\s+#.*)?\""
      "        }"
      "      }"
      "    }"
      "  }"
      "}"
  }
}
benchmark_configs: {
  id: "systemd-journal-remote-enabled"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure systemd-journal-remote is enabled"
    description:
      "Journald (via systemd-journal-remote) supports the ability to send log events it gathers to "
      "a remote log host or to receive messages from remote hosts, thus enabling centralised log "
      "management."
    rationale:
      "Storing log data on a remote host protects log integrity from local attacks. If an attacker "
      "gains root access on the local system, they could tamper with or remove log data that is "
      "stored on the local system."
    remediation:
      "Run the following command to enable systemd-journal-remote:\n"
      "\n```\n"
      "systemctl --now enable systemd-journal-upload.service\n"
      "```\n\n"
    cis_benchmark: {
      profile_level: 1
      severity: LOW
    }
    scan_instructions:
      "generic:{"
      "  check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{files_in_dir:{"
      "         dir_path:\"/etc/systemd/system/\""
      "        recursive: true"
      "        filename_regex: \"systemd-journal-upload.service\""
      "       }"
      "      }"
      "      existence:{should_exist:true}"
      "    }"
      "}}"
  }
}
benchmark_configs: {
  id: "journald-no-logs-from-remote-client"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure journald is not configured to receive logs from a remote client"
    description:
      "Journald supports the ability to receive messages from remote hosts, thus acting as a log "
      "server. Clients should not receive data from other hosts.\n"
      "NOTE:\n"
      "The same package, systemd-journal-remote, is used for both sending logs to "
      "remote hostsand receiving incominglogs.\n"
      "With regards to receiving logs, there are two services; systemd-journal-"
      "remote.socket and systemd-journal-remote.service."
    rationale:
      "If a client is configured to also receive data, thus turning it into a server, the client system is "
      "acting outside it's operational boundary."
    remediation:
      "Run the following command to disable systemd-journal-remote.socket:\n"
      "\n```\n"
      "systemctl --now mask systemd-journal-remote.socket\n"
      "```\n\n"
    cis_benchmark: {
      profile_level: 1
      severity: LOW
    }
    scan_instructions:
      "generic:{check_alternatives:{"
      "  file_checks:{"
      "    files_to_check:{"
      "      files_in_dir:{"
      "        dir_path:\"/etc/systemd/system\""
      "        recursive: true"
      "        filename_regex: \"systemd-journal-remote.service\""
      "      }"
      "    }"
      "    files_to_check:{"
      "      files_in_dir:{"
      "        dir_path:\"/etc/systemd/system\""
      "        recursive: true"
      "        filename_regex: \"systemd-journal-remote.socket\""
      "      }"
      "    }"
      "    existence:{should_exist: false}"
      "  }"
      "}}"
  }
}
benchmark_configs: {
  id: "journald-default-file-permissions-configured"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure journald default file permissions configured"
    description:
      "Journald will create log files that do not already exist on the system. This setting controls "
      "what permissions will be applied to these newly created files."
    rationale:
      "It is important to ensure that log files have the correct permissions to ensure that sensitive "
      "data is archived and protected."
    remediation:
      "If the default configuration is not appropriate for the site specific requirements, copy "
      "/usr/lib/tmpfiles.d/systemd.conf to /etc/tmpfiles.d/systemd.conf and modify as "
      "required. Requirements is either 0640 or site policy if that is less restrictive."
    cis_benchmark: {
      profile_level: 1
      severity: LOW
    }
    scan_instructions:
      "generic:{"
      "  check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{single_file:{"
      "        path:\"/etc/tmpfiles.d/systemd.conf\""
      "       }"
      "      }"
      "    permission:{"
      "      set_bits: 0640"
      "    }"
      "    }"
      "  }"
      "  check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{single_file:{"
      "        path:\"/usr/lib/tmpfiles.d/systemd.conf\""
      "       }"
      "      }"
      "    permission:{"
      "      set_bits: 0640"
      "    }"
      "    }"
      "    file_checks:{"
      "     files_to_check:{single_file:{path:\"/etc/tmpfiles.d/systemd.conf\"}}"
      "     existence:{should_exist: false}"
      "    }"
      "  }"
      "  check_alternatives:{"
      "    file_checks:{"
      "     files_to_check:{single_file:{path:\"/usr/lib/tmpfiles.d/systemd.conf\"}}"
      "     files_to_check:{single_file:{path:\"/etc/tmpfiles.d/systemd.conf\"}}"
      "     existence:{should_exist: false}"
      "    }"
      "}}"
  }
}
benchmark_configs: {
  id: "systemwide-crypto-policy-is-not-overridden"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure system-wide crypto policy is not over-ridden"
    description: "System-wide Crypto policy can be over-ridden or opted out of for openSSH"
    rationale:
      "Over-riding or opting out of the system-wide crypto policy could allow for the use of less "
      "secure Ciphers, MACs, KexAlgorithms and GSSAPIKexAlgorithm"
    remediation:
      "Run the following commands:\n"
      "\n```\n"
      "sed -ri \"s/\"\\s* (CRYPTO_POLICY\\s*=.*)$/# \\1/\" /etc/sysconfig/sshd\n"
      "systemctl reload sshd\n"
      "```\n\n"
    cis_benchmark: {
      profile_level: 1
      severity: LOW
    }
    scan_instructions:
      "generic:{"
      " check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{single_file:{path:\"/etc/sysconfig/sshd\"}}"
      "      content_entry:{"
      "        match_type: NONE_MATCH"
      "        match_criteria: {"
      "          filter_regex: \"\\\\s*CRYPTO_POLICY\\\\s*=.*\""
      "          expected_regex: \"\\\\s*CRYPTO_POLICY\\\\s*=.*\""
      "        }"
      "      }"
      "    }"
      " }"
      "}"
  }
}
benchmark_configs: {
  id: "custom-authselect-profile-is-used"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure custom authselect profile is used"
    description:
      "A custom profile can be created by copying and customizing one of the default profiles. The "
      "default profiles include: sssd, winbind, or the nis. This profile can then be customized to "
      "follow site specific requirements.\n"
      "You can select a profile for the authselect utility for a specific host. The profile will be "
      "applied to every user logging into the host."
    rationale:
      "A custom profile is required to customize many of the pam options.\n"
      "When you deploy a profile, the profile is applied to every user logging into the given host"
    remediation:
      "Run the following command to create a custom authselect profile:\n"
      "\n```\n"
      "authselect create-profile <custom-profile name> <options>\n"
      "```\n\n"
      "Example:\n"
      "\n```\n"
      "authselect create-profile custom-profile -b sssd --symlink-meta\n"
      "```\n\n"
      "Run the following command to select a custom authselect profile:\n"
      "\n```\n"
      "authselect select custom/<CUSTOM PROFILE NAME> {with-<OPTIONS>}\n"
      "```\n\n"
      "Example:\n"
      "\n```\n"
      "# authselect select custom/custom-profile with-sudo with-faillock without-nullok\n"
      "```\n\n"
      "References:\n"
      "1. authselect(8)"
    cis_benchmark: {
      profile_level: 1
      severity: LOW
    }
    scan_instructions:
      "generic:{check_alternatives:{"
      "  file_checks:{"
      "    files_to_check:{single_file:{path:\"/etc/authselect/authselect.conf\"}}"
      "    content_entry:{"
      "      match_type: ALL_MATCH_ANY_ORDER"
      "      match_criteria: {"
      # Expect a custom profile in the file.
      "        filter_regex: \"-\\\\s*custom/.*\""
      "        expected_regex: \"-\\\\s*custom/[a-z0-9A-Z_-]+\""
      "      }"
      "    }"
      "  }"
      "}"
      "check_alternatives:{"
      "  file_checks:{"
      "    files_to_check:{single_file:{path:\"/etc/authselect/authselect.conf\"}}"
      "    existence:{should_exist: false}"
      "  }"
      "}}"
  }
}
benchmark_configs: {
  id: "authselect-includes-with-faillock"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure authselect includes with-faillock"
    description:
      "The pam_faillock.so module maintains a list of failed authentication attempts per user "
      "during a specified interval and locks the account in case there were more than deny "
      "consecutive failed authentications. It stores the failure records into per-user files in the "
      "tally directory"
    rationale:
      "Locking out user IDs after n unsuccessful consecutive login attempts mitigates brute force"
      "password attacks against your systems."
    remediation:
      "Run the following commands to include the with-faillock option to the current authselect "
      "profile:\n"
      "\n```\n"
      "# authselect enable-feature with-faillock\n"
      "# authselect apply-changes\n"
      "```\n\n"
      "References:\n"
      "1. faillock(8) - Linux man page\n"
      "2. pam_faillock(8) - Linux man page\n"
    cis_benchmark: {
      profile_level: 1
      severity: LOW
    }
    scan_instructions:
      "generic:{check_alternatives:{"
      "  file_checks:{"
      "    files_to_check:{single_file:{path:\"/etc/pam.d/password-auth\"}}"
      "    files_to_check:{single_file:{path:\"/etc/pam.d/system-auth\"}}"
      "    content_entry:{"
      "      match_type: ALL_MATCH_ANY_ORDER"
      "      match_criteria: {"
      "        filter_regex: \"\\\\s*pam_faillock\\\\.so\""
      "        expected_regex: \"\\\\s*pam_faillock\\\\.so\""
      "      }"
      "    }"
      "  }"
      "}"
      "check_alternatives:{"
      "  file_checks:{"
      "    files_to_check:{single_file:{path:\"/etc/pam.d/password-auth\"}}"
      "    files_to_check:{single_file:{path:\"/etc/pam.d/system-auth\"}}"
      "    existence:{should_exist: false}"
      "  }"
      "}}"
  }
}

benchmark_configs: {
  id: "squashfs-mounting-disabled-rocky"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure mounting of squashfs filesystems is disabled"
    description:
      "The squashfs filesystem type is a compressed read-only Linux "
      "filesystem embedded in small footprint systems (similar to cramfs ). A "
      "squashfs image can be used without having to first decompress the image."
    rationale:
      "Removing support for unneeded filesystem types reduces the local attack "
      "surface of the server. If this filesystem type is not needed, disable "
      "it."
    remediation:
      "Edit or create a file in the /etc/modprobe.d/ directory ending in .conf "
      "with the lines that read install squashfs /bin/false and blacklist squashfs.\n"
      "Example: \n"
      "\n```\n"
      "printf \"install squashfs /bin/false "
      "blacklist squashfs "
      "\" >> /etc/modprobe.d/squashfs.conf\n"
      "```\n\n"
      "Run the following command to unload the squashfs module:\n"
      "\n```\n"
      "# rmmod squashfs\n"
      "```\n\n"
    cis_benchmark: {
      profile_level: 2
      severity: LOW
    }
    scan_instructions:
      "scan_type_specific:{instance_scanning:{"
      "  check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{single_file:{path:\"/proc/modules\"}}"
      "      content_entry:{"
      "        match_type: NONE_MATCH"
      "        match_criteria: {"
      "          filter_regex: \"squashfs\\\\s+.*\""
      "          expected_regex: \"squashfs .*\""
      "        }"
      "      }"
      "    }"
      "    file_checks:{"
      "      files_to_check:{files_in_dir:{"
      "        dir_path:\"/etc/modprobe.d\""
      "        filename_regex: \".*\\\\.conf\""
      "        recursive: true"
      "      }}"
      "      content_entry:{"
      "        match_type: ALL_MATCH_ANY_ORDER"
      "        match_criteria: {"
      "          filter_regex: \"install squashfs .*\""
      "          expected_regex: \"install squashfs /bin/(true|false)\""
      "        }"
      "      }"
      "    }"
      "  }"
      "}"
      "image_scanning:{"
      "  check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{files_in_dir:{"
      "        dir_path:\"/etc/modprobe.d\""
      "        filename_regex: \".*\\\\.conf\""
      "        recursive: true"
      "      }}"
      "      content_entry:{"
      "        match_type: ALL_MATCH_ANY_ORDER"
      "        match_criteria: {"
      "          filter_regex: \"install squashfs .*\""
      "          expected_regex: \"install squashfs /bin/(true|false)\""
      "        }"
      "      }"
      "    }"
      "  }"
      "}}"
  }
}
benchmark_configs: {
  id: "udf-mounting-disabled-rocky"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure mounting of udf filesystems is disabled"
    description:
      "The udf filesystem type is the universal disk format used to implement "
      "ISO/IEC 13346 and ECMA-167 specifications. This is an open vendor "
      "filesystem type for data storage on a broad range of media. This "
      "filesystem type is necessary to support writing DVDs and newer optical "
      "disc formats."
    rationale:
      "Removing support for unneeded filesystem types reduces the local "
      "attack surface of the system. If this filesystem type is not needed, "
      "disable it."
    remediation:
      "Edit or create a file in the /etc/modprobe.d/ directory ending in .conf "
      "with the lines that read install udf /bin/false and blacklist udf.\n"
      "Example: \n"
      "\n```\n"
      "printf \"install udf /bin/false "
      "blacklist udf "
      "\" >> /etc/modprobe.d/udf.conf\n"
      "```\n\n"
      "Run the following command to unload the udf module:\n"
      "\n```\n"
      "# rmmod udf\n"
      "```\n\n"
    cis_benchmark: {
      profile_level: 2
      severity: LOW
    }
    scan_instructions:
      "scan_type_specific:{instance_scanning:{"
      "  check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{single_file:{path:\"/proc/modules\"}}"
      "      content_entry:{"
      "        match_type: NONE_MATCH"
      "        match_criteria: {"
      "          filter_regex: \"udf .*\""
      "          expected_regex: \"udf .*\""
      "        }"
      "      }"
      "    }"
      "    file_checks:{"
      "      files_to_check:{files_in_dir:{"
      "        dir_path:\"/etc/modprobe.d\""
      "        filename_regex: \".*\\\\.conf\""
      "        recursive: true"
      "      }}"
      "      content_entry:{"
      "        match_type: ALL_MATCH_ANY_ORDER"
      "        match_criteria: {"
      "          filter_regex: \"install udf .*\""
      "          expected_regex: \"install udf /bin/(true|false)\""
      "        }"
      "      }"
      "    }"
      "  }"
      "}"
      "image_scanning:{"
      "  check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{files_in_dir:{"
      "        dir_path:\"/etc/modprobe.d\""
      "        filename_regex: \".*\\\\.conf\""
      "        recursive: true"
      "      }}"
      "      content_entry:{"
      "        match_type: ALL_MATCH_ANY_ORDER"
      "        match_criteria: {"
      "          filter_regex: \"install udf .*\""
      "          expected_regex: \"install udf /bin/(true|false)\""
      "        }"
      "      }"
      "    }"
      "  }"
      "}}"
  }
}
benchmark_configs: {
  id: "usb-storage-disabled-rocky"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Disable USB Storage"
    description:
      "USB storage provides a means to transfer and store files insuring persistence and "
      "availability of the files independent of network connection status. Its popularity and utility "
      "has led to USB-based malware being a simple and common means for network infiltration "
      "and a first step to establishing a persistent threat within a networked environment."
    rationale:
      "Restricting USB access on the system will decrease the physical attack surface for a device "
      "and diminish the possible vectors to introduce malware."
    remediation:
      "Edit or create a file in the /etc/modprobe.d/ directory ending in .conf\n"
      "Example: vim /etc/modprobe.d/usb_storage.conf\n"
      "and add the following line:\n"
      "\n```\n"
      "install usb-storage /bin/true\n"
      "```\n\n"
      "Run the following command to unload the usb-storage module:\n"
      "\n```\n"
      "rmmod usb-storage\n"
      "```\n\n"
    cis_benchmark: {
      profile_level: 2
      severity: LOW
    }
    scan_instructions:
      "scan_type_specific:{instance_scanning:{"
      "  check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{single_file:{path:\"/proc/modules\"}}"
      "      content_entry:{"
      "        match_type: NONE_MATCH"
      "        match_criteria: {"
      "          filter_regex: \"usb-storage .*\""
      "          expected_regex: \"usb-storage .*\""
      "        }"
      "      }"
      "    }"
      "    file_checks:{"
      "      files_to_check:{files_in_dir:{"
      "        dir_path:\"/etc/modprobe.d\""
      "        filename_regex: \".*\\\\.conf\""
      "        recursive: true"
      "      }}"
      "      content_entry:{"
      "        match_type: ALL_MATCH_ANY_ORDER"
      "        match_criteria: {"
      "          filter_regex: \"install usb-storage .*\""
      "          expected_regex: \"install usb-storage /bin/(true|false)\""
      "        }"
      "      }"
      "    }"
      "  }"
      "}"
      "image_scanning:{"
      "  check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{files_in_dir:{"
      "        dir_path:\"/etc/modprobe.d\""
      "        filename_regex: \".*\\\\.conf\""
      "        recursive: true"
      "      }}"
      "      content_entry:{"
      "        match_type: ALL_MATCH_ANY_ORDER"
      "        match_criteria: {"
      "          filter_regex: \"install usb-storage .*\""
      "          expected_regex: \"install usb-storage /bin/(true|false)\""
      "        }"
      "      }"
      "    }"
      "  }"
      "}}"
  }
}
benchmark_configs: {
  id: "selinux-mode-enforcing"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure the SELinux mode is enforcing"
    description:
      "SELinux can run in one of three modes: disabled, permissive, or enforcing:\n"
      "Enforcing - Is the default, and recommended, mode of operation; in enforcing mode "
      "SELinux operates normally, enforcing the loaded security policy on the entire "
      "system.\n"
      "Permissive - The system acts as if SELinux is enforcing the loaded security policy, "
      "including labeling objects and emitting access denial entries in the logs, but it does "
      "not actually deny any operations. While not recommended for production systems, "
      "permissive mode can be helpful for SELinux policy development.\n"
      "Disabled - Is strongly discouraged; not only does the system avoid enforcing the "
      "SELinux policy, it also avoids labeling any persistent objects such as files, making it "
      "difficult to enable SELinux in the future\n"
      "Note: you can set individual domains to permissive mode while the system runs in enforcing "
      "mode. For example, to make the httpd_t domain permissive:\n"
      "\n```\n"
      "# semanage permissive -a httpd_t\n"
      "```\n\n"
    rationale:
      "Running SELinux in disabled mode the system not only avoids enforcing the SELinux poli cy,"
      "it also avoids labeling any persistent objects such as files, making it difficult to enable"
      "SELinux in the future."
      "Running SELinux in Permissive mode, though helpful for developing SELinux policy, only"
      "logs access denial entries, but does not deny any operations."
    remediation:
      "Run one of the following commands to set SELinux's running mode:\n"
      "\n```\n"
      "# setenforce 1\n"
      "```\n\n"
      "Edit the /etc/selinux/config file to set the SELINUX parameter:\n"
      "\n```\n"
      "SELINUX=enforcing\n"
      "```\n\n"
      "References:\n"
      "https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/selinux_users_and_administrators_guide/sect-security-enhanced_linux-introduction-selinux_modes"
    cis_benchmark: {
      profile_level: 2
      severity: LOW
    }
    scan_instructions:
      "scan_type_specific:{instance_scanning:{"
      "      check_alternatives:{"
      "          file_checks:{"
      "              files_to_check:{single_file{path:\"/sys/fs/selinux/enforce\"}}"
      "              content:{content:\"1\"}"
      "          }"
      "          file_checks:{"
      "            files_to_check:{single_file:{path:\"/etc/selinux/config\"}}"
      "            content_entry:{"
      "                match_type: ALL_MATCH_ANY_ORDER"
      "                match_criteria: {"
      "                filter_regex: \"SELINUX=[a-zA-Z0-9]+\""
      "                expected_regex: \"SELINUX=enforcing\""
      "                }"
      "          }"
      "      }"
      "   }"
      "  }image_scanning:{"
      "      check_alternatives:{"
      "          file_checks:{"
      "            files_to_check:{single_file:{path:\"/etc/selinux/config\"}}"
      "            content_entry:{"
      "              match_type: ALL_MATCH_ANY_ORDER"
      "              match_criteria: {"
      "                filter_regex: \"SELINUX=[a-zA-Z0-9]+\""
      "                expected_regex: \"SELINUX=enforcing\""
      "              }"
      "            }"
      "          }"
      "       }"
      "  }"
      "  }"
  }
}
benchmark_configs: {
  id: "avahi-disabled-not-installed"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure Avahi Server is not installed"
    description:
      "Avahi is a free zeroconf implementation, including a system for multicast DNS/DNS-SD "
      "service discovery. Avahi allows programs to publish and discover services and hosts "
      "running on a local network with no specific configuration. For example, a user can plug a "
      "computer into a network and Avahi automatically finds printers to print to, files to look at "
      "and people to talk to, as well as network services running on the machine."
    rationale:
      "Automatic discovery of network services is not normally required for system functionality. "
      "It is recommended to remove this package to reduce the potential attack surface."
    remediation:
      "Run the following commands to stop, mask and remove avahi-autoipd and avahi:"
      "\n```\n"
      "# systemctl stop avahi-daemon.socket avahi-daemon.service\n"
      "# dnf remove avahi-autoipd avahi\n"
      "```\n\n"
    cis_benchmark: {
      profile_level: 2
      severity: LOW
    }
    scan_instructions:
      "generic:{check_alternatives:{"
      "    file_checks:{"
      "        files_to_check:{"
      "            files_in_dir:{"
      "                dir_path:\"/etc/systemd/system\""
      "                recursive: true"
      "                filename_regex: \"avahi-daemon.(service|socket)\""
      "        }}"
      "        existence:{should_exist: false}"
      "        non_compliance_msg: \"a config file in /etc/systemd/system enables avahi-daemon\""
      "        file_display_command: \"find /etc/systemd/system -name avahi-daemon.*\""
      "    }"
      "    file_checks: {"
      "        files_to_check:{"
      "            files_in_dir:{"
      "                dir_path: \"/usr/lib/systemd/system\""
      "                recursive: true"
      "                filename_regex: \"avahi-daemon.(service|socket)\""
      "        }}"
      "        existence:{should_exist: false}"
      "        non_compliance_msg: \"a config file in /usr/lib/systemd/system enables avahi-daemon\""
      "        file_display_command: \"find /usr/lib/systemd/system -name avahi-daemon.*\""
      "    }"
      "    file_checks: {"
      "        files_to_check:{single_file:{path:\"/usr/sbin/avahi-autoipd\"}}"
      "        existence:{should_exist: false}"
      "        non_compliance_msg: \"Executable file /usr/sbin/avahi-autoipd is available\""
      "        file_display_command: \"find /usr/sbin -name avahi-autoipd\""
      "    }"
      "    file_checks: {"
      "        files_to_check:{single_file:{path:\"/etc/avahi/avahi-autoipd.action\"}}"
      "        existence:{should_exist: false}"
      "        non_compliance_msg: \"Executable file /etc/avahi/avahi-autoipd.action is available\""
      "        file_display_command: \"find /etc/avahi -name avahi-autoipd.action\""
      "      }"
      "    }}"
  }
}
benchmark_configs: {
  id: "sctp-disabled"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure SCTP is disabled"
    description:
      "The Stream Control Transmission Protocol (SCTP) is a transport layer protocol used to "
      "support message oriented communication, with several streams of messages in one "
      "connection. It serves a similar function as TCP and UDP, incorporating features of both. It is "
      "message-oriented like UDP, and ensures reliable in-sequence transport of messages with "
      "congestion control like TCP."
    rationale:
      "If the protocol is not being used, it is recommended that kernel module not be loaded, "
      "disabling the service to reduce the potential attack surface."
    remediation:
      "Edit or create a file in the /etc/modprobe.d/ directory ending in .conf "
      "Example: \n"
      "\n```\n"
      "printf \"\n"
      "install sctp /bin/true\n"
      "\" >> /etc/modprobe.d/sctp.conf\n"
      "```\n\n"
      "Run the following command to unload the sctp module:\n"
      "\n```\n"
      "# rmmod stcp\n"
      "```\n\n"
    cis_benchmark: {
      profile_level: 2
      severity: LOW
    }
    scan_instructions:
      "scan_type_specific:{instance_scanning:{"
      "  check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{single_file:{path:\"/proc/modules\"}}"
      "      content_entry:{"
      "        match_type: NONE_MATCH"
      "        match_criteria: {"
      "          filter_regex: \"sctp\\\\s+.*\""
      "          expected_regex: \"sctp .*\""
      "        }"
      "      }"
      "    }"
      "    file_checks:{"
      "      files_to_check:{files_in_dir:{"
      "        dir_path:\"/etc/modprobe.d\""
      "        filename_regex: \".*\\\\.conf\""
      "        recursive: true"
      "      }}"
      "      content_entry:{"
      "        match_type: ALL_MATCH_ANY_ORDER"
      "        match_criteria: {"
      "          filter_regex: \"install sctp .*\""
      "          expected_regex: \"install sctp /bin/(true|false)\""
      "        }"
      "      }"
      "    }"
      "  }"
      "}"
      "image_scanning:{"
      "  check_alternatives:{"
      "    file_checks:{"
      "      files_to_check:{files_in_dir:{"
      "        dir_path:\"/etc/modprobe.d\""
      "        filename_regex: \".*\\\\.conf\""
      "        recursive: true"
      "      }}"
      "      content_entry:{"
      "        match_type: ALL_MATCH_ANY_ORDER"
      "        match_criteria: {"
      "          filter_regex: \"install sctp .*\""
      "          expected_regex: \"install sctp /bin/(true|false)\""
      "        }"
      "      }"
      "    }"
      "  }"
      "}}"
  }
}
benchmark_configs: {
  id: "dccp-disabled"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure DCCP is disabled"
    description:
      "The Datagram Congestion Control Protocol (DCCP) is a transport layer protocol that "
      "supports streaming media and telephony. DCCP provides a way to gain access to "
      "congestion control, without having to do it at the application layer, but does not provide in-"
      "sequence delivery."
    rationale:
      "If the protocol is not required, it is recommended that the drivers not be installed to reduce"
      "the potential attack surface."
    remediation:
      "Edit or create a file in the /etc/modprobe.d/ directory ending in .conf "
      "Example: \n"
      "\n```\n"
      "printf \"\n"
      "install dccp /bin/true\n"
      "\" >> /etc/modprobe.d/dccp.conf\n"
      "```\n\n"
      "Run the following command to unload the sctp module:\n"
      "\n```\n"
      "# rmmod dccp\n"
      "```\n\n"
    cis_benchmark: {
      profile_level: 2
      severity: LOW
    }
    scan_instructions:
      "scan_type_specific:{instance_scanning:{"
      "    check_alternatives:{"
      "      file_checks:{"
      "        files_to_check:{single_file:{path:\"/proc/modules\"}}"
      "        content_entry:{"
      "          match_type: NONE_MATCH"
      "          match_criteria: {"
      "            filter_regex: \"dccp\\\\s+.*\""
      "            expected_regex: \"dccp .*\""
      "          }"
      "        }"
      "      }"
      "      file_checks:{"
      "        files_to_check:{files_in_dir:{"
      "          dir_path:\"/etc/modprobe.d\""
      "          filename_regex: \".*\\\\.conf\""
      "          recursive: true"
      "        }}"
      "        content_entry:{"
      "          match_type: ALL_MATCH_ANY_ORDER"
      "          match_criteria: {"
      "            filter_regex: \"install dccp .*\""
      "            expected_regex: \"install dccp /bin/(true|false)\""
      "          }"
      "        }"
      "      }"
      "    }"
      "    check_alternatives:{"
      "        file_checks:{"
      "            files_to_check:{"
      "                files_in_dir:{"
      "                    dir_path:\"/boot\""
      "                    filename_regex: \"config-.*\""
      "                    recursive: true"
      "                }"
      "            }"
      "            content_entry:{"
      "                match_type: NONE_MATCH"
      "                match_criteria:{"
      "                    filter_regex: \".*(DCCP).*\""
      "                    expected_regex: \"[^#]*CONFIG_IP_DCCP.*\""
      "                }"
      "            }"
      "        }"
      "    }"
      "  }"
      "  image_scanning:{"
      "    check_alternatives:{"
      "      file_checks:{"
      "        files_to_check:{files_in_dir:{"
      "          dir_path:\"/etc/modprobe.d\""
      "          filename_regex: \".*\\\\.conf\""
      "          recursive: true"
      "        }}"
      "        content_entry:{"
      "          match_type: ALL_MATCH_ANY_ORDER"
      "          match_criteria: {"
      "            filter_regex: \"install sctp .*\""
      "            expected_regex: \"install sctp /bin/(true|false)\""
      "          }"
      "        }"
      "      }"
      "    }"
      "    check_alternatives:{"
      "        file_checks:{"
      "            files_to_check:{"
      "                files_in_dir:{"
      "                    dir_path:\"/boot\""
      "                    filename_regex: \"config-.*\""
      "                    recursive: true"
      "                }"
      "            }"
      "            content_entry:{"
      "                match_type: NONE_MATCH"
      "                match_criteria:{"
      "                    filter_regex: \".*(DCCP).*\""
      "                    expected_regex: \"[^#]*CONFIG_IP_DCCP.*\""
      "                }"
      "            }"
      "        }"
      "    }"
      "  }}"
  }
}
benchmark_configs: {
  id: "events-modifying-sudo-log-file-collected"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure events that modify the sudo log file are collected"
    description:
      "Monitor the sudo log file. If the system has been properly configured to disable the use of "
      "the su command and force all administrators to have to log in first and then use sudo to "
      "execute privileged commands, then all administrator commands will be logged to "
      "/var/log/sudo.log . Any time a command is executed, an audit event will be triggered as "
      "the /var/log/sudo.log file will be opened for write and the executed administration "
      "command will be written to the log."
    rationale:
      "Changes in /var/log/sudo.log indicate that an administrator has executed a command or "
      "the log file itself has been tampered with. Administrators will want to correlate the events "
      "written to the audit trail with the records written to /var/log/sudo.log to verify if "
      "unauthorized commands have been executed."
    remediation:
      "Edit or create a file in the /etc/audit/rules.d/ directory, ending in .rules extension, with "
      "the relevant rules to monitor events that modify the sudo log file.\n"
      "Example:\n"
      "\n```\n"
      "# {\n"
      "SUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,?"
      ".*//' -e 's/\"//g')\n"
      "[ -n \"${SUDO_LOG_FILE}\" ] && printf \""
      "-w ${SUDO_LOG_FILE} -p wa -k sudo_log_file"
      "\" >> /etc/audit/rules.d/50-sudo.rules \\"
      "|| printf \"ERROR: Variable 'SUDO_LOG_FILE_ESCAPED' is unset.\\\\n\""
      "}\n"
      "```\n\n"
      "Merge and load the rules into active configuration:\n"
      "\n```\n"
      "# augenrules --load\n"
      "```\n\n"
      "Check if reboot is required.\n"
      "\n```\n"
      "# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot "
      "required to load rules\\\\n\"; fi\n"
      "```\n\n"
    cis_benchmark: {
      profile_level: 2
      severity: LOW
    }
    scan_instructions:
      "scan_type_specific:{"
      "    instance_scanning:{"
      "        check_alternatives:{"
      "            file_checks:{"
      "                files_to_check:{single_file:{path: \"/etc/audit/audit.rules\"}}"
      "                content_entry:{"
      "                    match_type: ALL_MATCH_ANY_ORDER"
      "                    match_criteria:{"
      "                        filter_regex: \".*/var/log/sudo.log.*\""
      "                        expected_regex: \"^\\\\s*-w\\\\s*/var/log/sudo.log\\\\s*-p\\\\s*wa\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*$\""
      "                    }"
      "                }"
      "            }"
      "        }"
      "    }"
      "    image_scanning:{"
      "        check_alternatives:{"
      "            file_checks:{"
      "                files_to_check:{"
      "                    files_in_dir:{"
      "                        dir_path:\"/etc/audit/rules.d\""
      "                        recursive: true"
      "                        files_only: true"
      "                        filename_regex: \".*\\\\.rules\""
      "                    }"
      "                }"
      "                content_entry:{"
      "                    match_type: ALL_MATCH_ANY_ORDER"
      "                    match_criteria:{"
      "                        filter_regex: \".*/var/log/sudo.log.*\""
      "                        expected_regex: \"^\\\\s*-w\\\\s*/var/log/sudo.log\\\\s*-p\\\\s*wa\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*$\""
      "                    }"
      "                }"
      "            }"
      "        }"
      "    }"
      "}"
  }
}

benchmark_configs: {
  id: "ensure-kernel-module-load-unload-edit-collected"
  compliance_note: {
    version: { cpe_uri: "cpe:/o:rockylinux:rockylinux:8.5" version: "2.0.0" benchmark_document: "CIS Rocky Linux 8" }
    title: "Ensure kernel module loading unloading and modification is collected"
    description:
      "Monitor the loading and unloading of kernel modules. All the loading / listing / dependency "
      "checking of modules is done by kmod via symbolic links.\n"
      "The following system calls control loading and unloading of modules: \n"
      "init_module - load a module\n"
      "finit_module - load a module (used when the overhead of using cryptographically "
      "signed modules to determine the authenticity of a module can be avoided)\n"
      "delete_module - delete a module\n"
      "create_module - create a loadable module entry\n"
      "query_module - query the kernel for various bits pertaining to modules\n"
      "Any execution of the loading and unloading module programs and system calls will trigger "
      "an audit record with an identifier of modules."
    rationale:
      "Monitoring the use of all the various ways to manipulate kernel modules could provide "
      "system administrators with evidence that an unauthorized change was made to a kernel "
      "module, possibly compromising the security of the system."
    remediation:
      "Create audit rules"
      "Edit or create a file in the /etc/audit/rules.d/ directory, ending in .rules extension, with "
      "the relevant rules to monitor kernel module modification.\n"
      "64 Bit systems\n"
      "Example:\n"
      "\n```\n"
      "# {\n"
      "UID_MIN=$(awk '/^\\\\s*UID_MIN/{print $2}' /etc/login.defs)\n"
      "[ -n \"${UID_MIN}\" ] && printf \"\n"
      "-a always,exit -F arch=b64 -S\n"
      "init_module,finit_module,delete_module,create_module,query_module -F\n"
      "auid>=${UID_MIN} -F auid!=unset -k kernel_modules\n"
      "-a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>=${UID_MIN} -F\n"
      "auid!=unset -k kernel_modules\n"
      "\" >> /etc/audit/rules.d/50-kernel_modules.rules \\"
      "|| printf \"ERROR: Variable 'UID_MIN' is unset.\\\\n\"\n"
      "}\n"
      "```\n\n"
      "Load audit rules\n"
      "Merge and load the rules into active configuration:\n"
      "\n```\n"
      "# augenrules --load\n"
      "```\n\n"
      "Check if reboot is required.\n"
      "\n```\n"
      "# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot\""
      "required to load rules\\\\n\"; fi\n"
      "```\n\n"
      "32 Bit systems\n"
      "Follow the same procedures as for 64 bit systems and ignore any entries with b64."
    cis_benchmark: {
      profile_level: 2
      severity: LOW
    }
    scan_instructions:
      "scan_type_specific:{"
      "    instance_scanning:{"
      "        check_alternatives:{"
      "            file_checks:{"
      "                files_to_check:{single_file:{path:\"/etc/login.defs\"}}"
      "                content_entry:{"
      "                    match_type: ALL_MATCH_ANY_ORDER"
      "                    match_criteria:{"
      "                        filter_regex: \"UID_MIN.*\""
      "                        expected_regex: \"UID_MIN\\\\s*1000\\\\s*\""
      "                    }"
      "                }"
      "                non_compliance_msg: \"If UID_MIN is set to a value different from 1000 in /etc/login.defs, this check will fail.\""
      "                file_display_command: \"grep '^UID_MIN' /etc/login.defs\""
      "            }"
      "            file_checks:{"
      "                files_to_check:{single_file:{path:\"/proc/cpuinfo\"}}"
      "                content_entry:{"
      "                    match_type: ALL_MATCH_ANY_ORDER"
      "                    match_criteria:{"
      "                        filter_regex: \"flags\\\\s*:.*\""
      "                        expected_regex: \".*\\\\slm\\\\s.*\""
      "                    }"
      "                }"
      "            }"
      "            file_checks:{"
      "                files_to_check:{single_file:{path: \"/etc/audit/audit.rules\"}}"
      "                content_entry:{"
      "                    match_type: ALL_MATCH_ANY_ORDER"
      "                    match_criteria:{"
      "                        filter_regex: \".*/usr/bin/kmod.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*path=/usr/bin/kmod\\\\s*-F\\\\s*perm=x\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b32.*init_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b32\\\\s*-S\\\\s*([a-zA-Z_]+,)*init_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b32.*finit_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b32\\\\s*-S\\\\s*([a-zA-Z_]+,)*finit_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b32.*delete_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b32\\\\s*-S\\\\s*([a-zA-Z_]+,)*delete_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b32.*create_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b32\\\\s*-S\\\\s*([a-zA-Z_]+,)*create_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b32.*query_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b32\\\\s*-S\\\\s*([a-zA-Z_]+,)*query_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b64.*init_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b64\\\\s*-S\\\\s*([a-zA-Z_]+,)*init_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b64.*finit_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b64\\\\s*-S\\\\s*([a-zA-Z_]+,)*finit_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b64.*delete_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b64\\\\s*-S\\\\s*([a-zA-Z_]+,)*delete_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b64.*create_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b64\\\\s*-S\\\\s*([a-zA-Z_]+,)*create_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b64.*query_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b64\\\\s*-S\\\\s*([a-zA-Z_]+,)*query_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                }"
      "            }"
      "        }"
      "        check_alternatives:{"
      "            file_checks:{"
      "                files_to_check:{single_file:{path:\"/etc/login.defs\"}}"
      "                content_entry:{"
      "                    match_type: ALL_MATCH_ANY_ORDER"
      "                    match_criteria:{"
      "                        filter_regex: \"UID_MIN.*\""
      "                        expected_regex: \"UID_MIN\\\\s*1000\\\\s*\""
      "                    }"
      "                }"
      "                non_compliance_msg: \"If UID_MIN is set to a value different from 1000 in /etc/login.defs, this check will fail.\""
      "                file_display_command: \"grep '^UID_MIN' /etc/login.defs\""
      "            }"
      "            file_checks:{"
      "                files_to_check:{single_file:{path: \"/etc/audit/audit.rules\"}}"
      "                content_entry:{"
      "                    match_type: ALL_MATCH_ANY_ORDER"
      "                    match_criteria:{"
      "                        filter_regex: \".*/usr/bin/kmod.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*path=/usr/bin/kmod\\\\s*-F\\\\s*perm=x\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b32.*init_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b32\\\\s*-S\\\\s*([a-zA-Z_]+,)*init_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b32.*finit_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b32\\\\s*-S\\\\s*([a-zA-Z_]+,)*finit_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b32.*delete_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b32\\\\s*-S\\\\s*([a-zA-Z_]+,)*delete_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b32.*create_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b32\\\\s*-S\\\\s*([a-zA-Z_]+,)*create_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*b32.*query_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b32\\\\s*-S\\\\s*([a-zA-Z_]+,)*query_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                }"
      "            }"
      "        }"
      "    }"
      "    image_scanning:{"
      "        check_alternatives:{"
      "            file_checks:{"
      "                files_to_check:{single_file:{path:\"/etc/login.defs\"}}"
      "                content_entry:{"
      "                    match_type: ALL_MATCH_ANY_ORDER"
      "                    match_criteria:{"
      "                        filter_regex: \"UID_MIN.*\""
      "                        expected_regex: \"UID_MIN\\\\s*1000\\\\s*\""
      "                    }"
      "                }"
      "                non_compliance_msg: \"If UID_MIN is set to a value different from 1000 in /etc/login.defs, this check will fail.\""
      "                file_display_command: \"grep '^UID_MIN' /etc/login.defs\""
      "            }"
      "            file_checks:{"
      "                files_to_check:{files_in_dir:{"
      "                    dir_path:\"/etc/audit/rules.d\""
      "                    recursive: true"
      "                    files_only: true"
      "                    filename_regex: \".*\\\\.rules\""
      "                }}"
      "                content_entry:{"
      "                    match_type: ALL_MATCH_ANY_ORDER"
      "                    match_criteria:{"
      "                        filter_regex: \".*/usr/bin/kmod.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*path=/usr/bin/kmod\\\\s*-F\\\\s*perm=x\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*init_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b[2346]{2}\\\\s*-S\\\\s*([a-zA-Z_]+,)*init_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*finit_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b[2346]{2}\\\\s*-S\\\\s*([a-zA-Z_]+,)*finit_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*delete_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b[2346]{2}\\\\s*-S\\\\s*([a-zA-Z_]+,)*delete_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*create_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b[2346]{2}\\\\s*-S\\\\s*([a-zA-Z_]+,)*create_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                    match_criteria:{"
      "                        filter_regex: \".*query_module.*\""
      "                        expected_regex: \"\\\\s*-a\\\\s*always,exit\\\\s*-F\\\\s*arch=b[2346]{2}\\\\s*-S\\\\s*([a-zA-Z_]+,)*query_module(,[a-zA-Z_]+)*\\\\s*-F\\\\s*auid>=1000\\\\s*-F\\\\s*auid!=(unset|-1|4294967295)\\\\s*(-F\\\\s*key=|-k)\\\\s*[!-~]*\\\\s*\""
      "                    }"
      "                }"
      "            }"
      "        }"
      "    }"
      "}"

  }
}
